# W-TinyLFU 缓存淘汰策略

## 项目架构目录
w_tinylfu_cache/
├── CMakeLists.txt
├── include/
│   └── tinylfu/
│       ├── api/
│       │   ├── cache.h
│       │   └── loading_cache.h
│       ├── policy/
│       │   ├── eviction_policy.h
│       │   └── expiration_policy.h
│       └── sketch/
│           └── frequency_sketch.h
├── src/
│   ├── core/
│   │   ├── cache_builder.cpp
│   │   └── w_tiny_lfu_cache.cpp
│   ├── policy/
│   │   ├── segmented_lru_policy.cpp
│   │   └── timer_wheel.cpp
│   ├── sketch/
│   │   └── frequency_sketch.cpp
│   └── concurrent/
│       ├── read_buffer.cpp
│       └── maintenance_task.cpp
├── internal/
│   ├── node.h
│   ├── hashing.h
│   └── intrusive_list.h
└── tests/
    ├── policy/
    │   └── test_slru_policy.cpp
    └── sketch/
        └── test_frequency_sketch.cpp

## Loading Cache窗口缓存策略
窗口缓存作为“准入门槛”，在新数据初次仅此TinyLFU时存入窗口缓存，避免一次性数据直接进入主缓存。窗口缓存采用LRU策略，当窗口缓存满时淘汰最久未被访问的数据。一般而言，我们默认将窗口缓存的大小设置为主缓存的“1%”（该项数值将被设置为在conf中作为输入参数设定）。

### 缓存逻辑
#### 1. 通过LRU管理存活时间
+ 数据被插入或访问时按照LRU逻辑更新
+ 窗口缓存满时，将淘汰**最久未被访问**的数据，该数据作为**候选数据**
    + 当主缓存的`probation`部分未满，直接插入**候选数据**
    + 当主缓存的`probation`部分已满，**候选数据**与**受害者数据**在TinyLFU过滤器竞争。（见eviction_policy部分）
 
#### 2. 关键逻辑
+ **访问次数** ≠ **淘汰条件**：窗口缓存的淘汰机制仅与LRU有关，而非LFU的访问次数。
+ **频率统计的延迟性**：数据的访问频率由`Count-Min Sketch`统计，但频率更新仅在数据进入主缓存的`probation`之后才会触发。窗口缓存中的数据即使被多次访问，其频率也不会计入到主缓存的数据频率中，因此无法通过频率竞争进入`probation`。
+ **`probation`的准入门槛**：`probation`的设计目的是筛选“存活超过窗口的候选数据”，而非直接接纳窗口中的高频数据。数据必须被窗口缓存淘汰，才能获得进入观察区的资格。
+ **候选数据的频率来源**：候选数据的频率是其在窗口缓存中被淘汰前的**累计访问次数**，而非仅窗口内的访问次数。例如，若数据在窗口中被访问3次后被淘汰，其频率为3。进入观察区之后若再次被访问，频率会继续累加。


## CMS —— Count-Min Sketch
Count-Min Sketch（CMS）是 W-TinyLFU 中用于高效估计键访问频率的核心组件，所谓`sketch`就是用很少的一点数据来描述全体数据的特性，牺牲了准确性但是代价变得很低。。

### 设计核心逻辑
+ 用多个**哈希函数**将键映射到一个二维数组（计数器矩阵），通过多个位置的计数近似键的真实访问频率。
+ 采用取**最小值**的方式来减小哈希冲突导致的误差（多个哈希位置取最小值更接近真实频率）。
+ 支持**频率衰减**（右移操作），使得频率反应近期访问模式。（核心特性）

### 设计细节
+ 计数器的紧凑设计
    + 思路：将多个计数器打包到1个字节中（4位计数器 -> 1字节存2个，2位计数器 -> 1个字节存4个）
    + 实现：通过`byte_pos = (idx * bits_per_counter_) / 8`计算计数器所在字节，bit_offset计算字节内偏移，用掩码提取 / 更新计数器值。
+ 哈希函数设计
    + **独立性**：每个深度（行）使用不同的随机种子，确保哈希函数尽可能独立，减少系统冲突。
    + **映射范围**：通过`hash_val & width`将哈希值约束在`[0, width - 1]`，对应计数器矩阵的列索引。
 + **频率衰减机制**（核心）
     + 目的：让频率统计反映近期访问模式，避免历史高频数据长期占据缓存（如某个键过去访问 100 次，但最近 1 小时未访问，其频率应衰减）。
     + 实现：Decay()方法对所有计数器执行右移一位（相当于count = count >> 1），例如：
            - 计数器值8（1000）→ 右移后4（100）
            - 计数器值3（0011）→ 右移后1（0001）
     + 触发时机：通常由后台线程定期调用（如每处理 N 次访问后），W-TinyLFU 中默认每 15 次访问触发一次衰减。
+ 频率估计的误差控制
    + 取最小值：同一键经多个哈希函数映射到不同计数器，取其中最小值作为频率估计，减少哈希冲突导致的高估（冲突会使计数器值偏大，最小值更接近真实值）。
    + 参数权衡：
        - width_越大（列数越多）→ 冲突概率越低→ 估计越准，但内存占用越高；
        - depth_越大（行数越多）→ 取最小值的误差越小，但计算开销越大（需多次哈希）。
        - 推荐配置：width_=16384，depth_=4，bits_per_counter_=4（平衡内存与精度）。
+ 线程安全考量
    + 读写计数器矩阵时需保证线程安全


## SLRU —— 主缓缓存策略
SLRU 是 W-TinyLFU 主缓存的核心淘汰策略，用于解决 “如何从候选数据中筛选高频有用数据” 的问题。其核心目标是：通过分区管理和 LRU 顺序维护，结合频率统计（Count-Min Sketch），实现 “既保留近期高频数据，又避免一次性数据占据缓存” 的平衡。

### 核心设计逻辑
#### 1. 分区管理
SLRU将主缓存分为两个隔离的区域，通过严格的状态转移规则来迁移数据。
+ **Probation(观察区)**:
    + 功能：接收从窗口缓存淘汰的**候选数据**。
    + 特点：容量较小为总缓存的10%~20%，采用LRU算法管理。
+ **Protection(保护区)**:
    + 功能：保护高频数据不轻易淘汰，提高缓存命中率。
    + 特点：容量较大，采用LRU算法管理，数据不会直接淘汰，只会降低到`Probation`区。

#### 2. 数据生命周期与状态迁移规则
数据在 SLRU 中的流转遵循 “观察→晋升→保护→降级” 的闭环，核心规则如下：
1. **初始进入**：从窗口缓存淘汰的候选数据，首先进入`Probation`区（观察区），按 “最近访问” 顺序（LRU 头部）插入。
2. **访问触发晋升**：若`Probation`区的数据被再次访问，立即晋升至`Protected`区（保护区），并插入`Protected`区 LRU 头部（标记为 “最近访问”）。
3. **保护区满员降级**：若`Protected`区已满，新数据晋升时，将`Protected`区最久未访问的数据（LRU 尾部）降级至`Probation`区（给新数据腾出空间）。
4. **观察区满员淘汰**：若`Probation`区已满，新候选数据需与`Probation`区最久未访问的数据（LRU 尾部，称为 “受害者”）通过 CMS 频率竞争 —— 频率高者留存，低者被淘汰出主缓存。

#### 3. 与CMS的关系
SLRU 本身不直接统计频率，而是依赖 CMS 实现 “公平竞争”：
+ 当`Probation`区满员时，候选数据（新进入的窗口淘汰数据）与 “受害者”（`Probation`区最久未访问数据）的频率通过 CMS 获取；
+ **留存规则**：频率更高的一方留在 Probation 区，另一方被淘汰（确保缓存资源向高频数据倾斜）。

### 核心数据结构
#### 1. 分区存储：双LRU链表
SLRU 采用两个侵入式链表（intrusive_list） 分别管理`Probation`和`Protected`区。
+ **侵入式链表优势**：节点自身包含指针（无需额外封装），空间局部性好；插入/删除操作仅需修改指针，时间复杂度O(1)；一个数据节点可以存储在多个链表中，扩展性好；适合高频缓存操作。
+ **哨兵节点（head_）**：简化空链表 / 边界节点的处理（如空链表时 head_.prev = head_.next = &head_），避免 null 指针判断。

#### 2. 缓存节点（CacheNode）设计
节点需同时支持链表链接和状态标记。
```cpp
template <typename Key, typename Value>
struct CacheNode : IntrusiveListNode<CacheNode<Key, Value>> {
    Key key;                // 缓存键
    Value value;            // 缓存值
    bool is_in_protected;   // 状态标记：true=保护区，false=观察区
};
```

### 实现关键细节
1. **哨兵节点的作用**：
链表通过哨兵节点（head_）统一空链表 / 非空链表的处理逻辑，避免插入 / 删除时的 null 指针判断（如空链表时 head_.next = head_.prev = &head_）。

3. **状态标记的必要性**：
is_in_protected 标记避免了 “通过遍历链表判断节点所属区域” 的低效操作，使访问时的状态迁移逻辑从 O (n) 降至 O (1)。

3. **与`CMS`的协同边界**：
SLRU仅在 “观察区满员” 时触发频率竞争，其他场景（如晋升、降级）仅依赖 LRU 顺序，减少对 CMS 的依赖（降低计算开销）。

4. **线程安全考量**：
若用于多线程场景，需在链表操作（push_front/erase）和状态标记更新时加锁，避免并发修改导致的链表指针混乱。
